// +build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"log"
)

func genExpr(bw int, i int, startBit int) (expr string, newStartBit int) {
	byteShift := 0
	firstCurByteBit := startBit - startBit%8
	for bw != 0 {
		curByte := startBit / 8
		bitsInCurByte := bw
		if bitsLeft := startBit - firstCurByteBit + 1; bitsInCurByte > bitsLeft {
			bitsInCurByte = bitsLeft
		}
		shiftSize := 7 - startBit%8
		mask := 1<<uint(bitsInCurByte) - 1

		if len(expr) != 0 {
			expr += " | "
		}
		expr += fmt.Sprintf("uint((data[%d] >> %d) & %d) << %d", curByte, shiftSize, mask, byteShift)

		bw -= bitsInCurByte
		startBit -= bitsInCurByte
		if startBit < firstCurByteBit {
			startBit = firstCurByteBit + 15
			firstCurByteBit += 8
		}
		byteShift += bitsInCurByte
	}
	return "int32(" + expr + ")", startBit
}

func genFunc(out io.Writer, bw int) {
	fmt.Fprintf(out, "func unpack8int32_%d(data []byte) (a [8]int32) {\n", bw)
	fmt.Fprintf(out, "\t_ = a[7]\n")
	fmt.Fprintf(out, "\t_ = data[%d]\n", bw-1)
	startBit := 7
	var expr string
	for i := 0; i < 8; i++ {
		expr, startBit = genExpr(bw, i, startBit)
		fmt.Fprintf(out, "\ta[%d] = %s\n", i, expr)
	}
	fmt.Fprintf(out, "\treturn\n")
	fmt.Fprintf(out, "}\n\n")
}

func main() {
	buf := new(bytes.Buffer)

	fmt.Fprintf(buf, "package parquet\n\n")
	fmt.Fprint(buf, "// Code generated by \"bitpacking_gen.go\"; DO NOT EDIT.\n\n")
	for i := 1; i <= 32; i++ {
		genFunc(buf, i)
	}

	src, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	err = ioutil.WriteFile("bp.go", src, 0644)
	if err != nil {
		log.Fatal(err)
	}
}
